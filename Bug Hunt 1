
---

# Task: Bug Investigation & Solution Design (Do NOT Implement)

## Context
You're investigating CPLight, a WoW TBC Anniversary (2.5.5) gamepad addon. Five potential bugs have been identified in the refactor plan. Your job is to **hunt for these bugs, confirm they exist, understand their impact, and design solutions** - but **DO NOT implement any code**.

**Important API Note:** TBC Anniversary 2.5.5 uses the same API and strict security guidelines as World of Warcraft retail 12.0.1. Treat combat lockdown, taint restrictions, and protected action system rules as identical to modern retail WoW.

---

## Your Mission

### Phase 1: Bug Hunting
For each suspected bug:
1. ðŸ” **Locate** - Find the problematic code
2. âœ… **Confirm** - Does the bug actually exist?
3. ðŸ“Š **Assess Impact** - How bad is it? (Critical/High/Medium/Low)
4. ðŸ§ª **Reproduce** - What triggers it?

### Phase 2: Solution Design
For each confirmed bug:
1. ðŸ’¡ **Design Solution** - How to fix it (detailed pseudo-code)
2. ðŸ§ª **Test Cases** - How to verify fix works
3. âš ï¸ **Edge Cases** - What could go wrong
4. ðŸš€ **Improvements** - Better approaches or optimizations

### Phase 3: Comprehensive Report
Provide structured analysis with:
- Bug confirmation status
- Impact assessment
- Reproduction steps
- Detailed solution design (NOT implementation)
- Test cases and edge cases
- Alternative approaches

---

## Suspected Bugs to Investigate

### Bug 1: Unnecessary Graph Rebuilds (Performance Issue)

**Suspected Problem:**
Graph is invalidated and rebuilt every time a UI frame closes, even if the user immediately reopens the same frame.

**Where to Look:**
- Hijack.lua - DisableNavigation() method
- Hijack.lua - EnableNavigation() method
- NavigationGraph.lua - InvalidateGraph() method

**Investigation Steps:**
1. Find where InvalidateGraph() is called
2. Check if it's called on every DisableNavigation()
3. Check if frame list is tracked anywhere
4. Look for comparison logic before rebuilding

**Expected Findings:**
```lua
// Suspected problematic code:
function Hijack:DisableNavigation()
    // ... cleanup ...
    NavGraph:InvalidateGraph()  // âŒ Always invalidates
end

function Hijack:EnableNavigation()
    // No check if graph is still valid
    NavGraph:BuildGraph(frames)  // âŒ Always rebuilds
end
```

**Impact Assessment Criteria:**
- **Critical:** Causes crashes or data loss
- **High:** Significant performance degradation (>100ms delay)
- **Medium:** Noticeable performance impact (20-50ms delay)
- **Low:** Minor inefficiency (<20ms)

**Questions to Answer:**
- Is the graph actually rebuilt every time?
- How expensive is graph building? (check node count in logs)
- Does it track previous frame list anywhere?
- What's the cost of BuildGraph() call?

**Solution Design Requirements:**
- Track which frames were used for current graph
- Compare new frame list to previous
- Only rebuild if different
- Handle edge cases (nil frames, combat, mid-session changes)

**Test Cases to Design:**
```
Test 1: Same Frame Reopen (Should NOT Rebuild)
  1. Open CharacterFrame
  2. Graph built (log should show "Building navigation graph")
  3. Close CharacterFrame
  4. Immediately reopen CharacterFrame
  5. VERIFY: No "Building navigation graph" log
  6. VERIFY: Navigation still works

Test 2: Different Frame (Should Rebuild)
  1. Open CharacterFrame (graph built)
  2. Close CharacterFrame
  3. Open ContainerFrame1 (different frame)
  4. VERIFY: "Building navigation graph" log appears
  5. VERIFY: Correct nodes for bags shown

Test 3: Additional Frame (Should Rebuild)
  1. Open CharacterFrame (graph built with 1 frame)
  2. Keep CharacterFrame open, open ContainerFrame1
  3. VERIFY: Graph rebuilt with both frames
  4. VERIFY: Can navigate between both windows
```

**Edge Cases to Consider:**
```
Edge 1: Frame List Order
  Previous: [CharacterFrame, ContainerFrame1]
  Current:  [ContainerFrame1, CharacterFrame]
  Question: Same frames, different order - rebuild or not?

Edge 2: Combat Interruption
  1. Open CharacterFrame (graph built)
  2. Enter combat (navigation disabled)
  3. Close CharacterFrame, open SpellBookFrame (during combat)
  4. Exit combat
  5. Question: What frame list should be used?

Edge 3: Frame Content Changes
  1. Open ContainerFrame1 with 5 items (5 button nodes)
  2. Close bags
  3. Add 20 items to bags (now 25 buttons)
  4. Reopen bags
  5. Question: Same frame but different nodes - rebuild?

Edge 4: Nil/Empty Frame Lists
  Previous: [CharacterFrame]
  Current:  [] (no visible frames)
  Question: How to handle empty list?

Edge 5: Rapid Toggle
  Open/Close/Open/Close/Open CharacterFrame rapidly
  Question: Does comparison logic handle this?
```

**Alternative Solutions to Explore:**
```
Option A: Frame List Comparison (Recommended)
  - Track frame names/objects from last build
  - Compare before rebuilding
  - Pros: Accurate, handles most cases
  - Cons: Doesn't detect content changes

Option B: Frame + Node Count Tracking
  - Track frame list AND node count
  - Rebuild if either changes
  - Pros: Detects content changes too
  - Cons: Node count could be same by coincidence

Option C: Timestamp + Validation
  - Track build timestamp
  - Validate graph on enable (check nodes still visible)
  - Rebuild if validation fails
  - Pros: Handles dynamic changes
  - Cons: More complex validation logic

Option D: Aggressive Caching
  - Never invalidate unless explicit trigger
  - Validate nodes on each navigation
  - Rebuild only on validation failure
  - Pros: Minimal rebuilds
  - Cons: Could navigate to invalid nodes
```

---

### Bug 2: Widget State Corruption on Enable Failure (Stability Issue)

**Suspected Problem:**
If EnableNavigation() fails partway through (e.g., graph build fails, widget creation fails), widgets and bindings may be left in an invalid state with no cleanup.

**Where to Look:**
- Hijack.lua - EnableNavigation() method
- Hijack.lua - DisableNavigation() method
- Check for error handling (pcall, if/else checks)

**Investigation Steps:**
1. Read EnableNavigation() completely
2. Identify all state mutations (widgets, bindings, flags)
3. Check if there's error handling (pcall/xpcall)
4. Check if failure paths clean up partial state
5. Look for early returns without cleanup

**Expected Findings:**
```lua
// Suspected problematic code:
function Hijack:EnableNavigation()
    local frames = self:_CollectVisibleFrames()
    if not frames then return end  // âŒ Early return, no cleanup
    
    NavGraph:BuildGraph(frames)  // âŒ What if this fails?
    
    self.IsActive = true  // âŒ Set before success confirmed
    
    // Set up widgets
    local widget1 = Driver:GetWidget('PAD1', 'Hijack')
    SetOverrideBindingClick(widget1, ...)  // âŒ What if this fails?
    
    // More setup...
    // No try/catch or cleanup on failure
end
```

**Impact Assessment Criteria:**
- **Critical:** Leaves addon in broken state, requires /reload
- **High:** Requires manual cleanup or DisableNavigation call
- **Medium:** Minor state inconsistency
- **Low:** Cosmetic issue only

**Questions to Answer:**
- Is there any error handling in EnableNavigation()?
- What happens if BuildGraph() returns false?
- What happens if widget creation fails?
- What happens if binding setup fails mid-way?
- Is IsActive set before or after all setup?
- Are there multiple early returns without cleanup?

**Solution Design Requirements:**
- Wrap EnableNavigation logic in error handler
- Track setup progress (which steps completed)
- On failure, rollback completed steps
- Call DisableNavigation() to clean up
- Log detailed error information
- Return success/failure boolean

**Test Cases to Design:**
```
Test 1: Graph Build Failure
  MOCK: NavGraph:BuildGraph() returns false
  ACTION: Call EnableNavigation()
  VERIFY: IsActive = false
  VERIFY: No widgets configured
  VERIFY: No bindings set
  VERIFY: Error logged

Test 2: Widget Creation Failure
  MOCK: Driver:GetWidget() returns nil
  ACTION: Call EnableNavigation()
  VERIFY: IsActive = false
  VERIFY: Cleanup called
  VERIFY: No orphaned bindings

Test 3: Binding Setup Failure
  MOCK: SetOverrideBindingClick() fails (combat lockdown)
  ACTION: Call EnableNavigation()
  VERIFY: IsActive = false
  VERIFY: Partial bindings cleared
  VERIFY: Widgets released

Test 4: Exception During Setup
  MOCK: Inject error in middle of EnableNavigation
  ACTION: Call EnableNavigation()
  VERIFY: No Lua errors propagate
  VERIFY: Cleanup executed
  VERIFY: Addon still functional
```

**Edge Cases to Consider:**
```
Edge 1: Combat Lockdown During Enable
  If combat starts mid-EnableNavigation, bindings fail
  Must detect and abort gracefully

Edge 2: Partial Widget Setup
  Widget 1-3 set up, widget 4 fails
  Must release widgets 1-3

Edge 3: Nested Enable Calls
  EnableNavigation called while already enabling
  Should detect and prevent

Edge 4: Disable Called During Enable
  User closes UI mid-setup
  Race condition between enable/disable

Edge 5: Graph Valid But Node Invalid
  Graph builds successfully
  First node is nil or invalid
  SetFocus() fails
```

**Alternative Solutions to Explore:**
```
Option A: pcall Wrapper (Simple)
  local success, err = pcall(function()
    // All setup here
  end)
  if not success then cleanup() end
  
  Pros: Simple, catches all errors
  Cons: Less granular error reporting

Option B: Transaction Pattern (Robust)
  Track each setup step
  On failure, rollback in reverse order
  
  Pros: Precise cleanup
  Cons: More complex code

Option C: State Machine (Advanced)
  States: Idle â†’ GraphBuilding â†’ WidgetSetup â†’ Active
  Each state has enter/exit/rollback handlers
  
  Pros: Very robust, clear flow
  Cons: Significant complexity

Option D: Validation Before Commit (Safe)
  Perform all checks first (dry run)
  Only mutate state if all pass
  
  Pros: Safest approach
  Cons: Duplicates validation logic
```

---

### Bug 3: Redundant NODE Library Calls (Performance Issue)

**Suspected Problem:**
UpdateGauntletPosition() calls NODE.GetCenterScaled() every time the gauntlet moves, even though node positions are already cached in the NavigationGraph.

**Where to Look:**
- Hijack.lua - UpdateGauntletPosition() method
- NavigationGraph.lua - Check if positions are cached
- Look for other places calling NODE.GetCenterScaled()

**Investigation Steps:**
1. Find UpdateGauntletPosition() implementation
2. Check if it calls NODE.GetCenterScaled()
3. Check NavigationGraph._BuildNodeArray() - are x/y stored?
4. Check if GetNodePosition() method exists
5. Look for other NODE library calls in Hijack.lua

**Expected Findings:**
```lua
// Suspected problematic code:
function Hijack:UpdateGauntletPosition(node)
    local x, y = NODE.GetCenterScaled(node)  // âŒ Expensive repeated call
    self.Gauntlet:SetPoint("BOTTOMLEFT", UIParent, "BOTTOMLEFT", x - 8, y + 8)
end

// But in NavigationGraph.lua:
graph.nodes[index] = {
    node = node,
    x = x,  // âœ… Already cached!
    y = y,
}
```

**Impact Assessment Criteria:**
- **Critical:** Causes frame drops or stuttering
- **High:** Noticeable performance impact (>5ms per call)
- **Medium:** Minor performance issue (1-5ms per call)
- **Low:** Negligible impact (<1ms)

**Questions to Answer:**
- Is NODE.GetCenterScaled() called in UpdateGauntletPosition()?
- How often is UpdateGauntletPosition() called? (every frame? on navigate?)
- Are positions cached in NavigationGraph?
- Does NavGraph:GetNodePosition() exist and return cached values?
- Are there other places calling NODE library unnecessarily?
- What's the cost of NODE.GetCenterScaled() vs simple table lookup?

**Solution Design Requirements:**
- Get node index from NavGraph:NodeToIndex()
- Use NavGraph:GetNodePosition(index) for cached x/y
- Validate node is in graph before accessing
- Handle nil cases gracefully
- Keep fallback to NODE if node not in graph

**Test Cases to Design:**
```
Test 1: Normal Navigation (Cached Position)
  1. Enable navigation with CharacterFrame
  2. Navigate to first button
  3. VERIFY: Gauntlet positioned correctly
  4. VERIFY: NavGraph:GetNodePosition() called (not NODE.GetCenterScaled)
  5. Navigate to second button
  6. VERIFY: Gauntlet follows cursor

Test 2: Node Not In Graph (Fallback)
  1. Enable navigation
  2. Mock: Node exists but not in graph
  3. Call UpdateGauntletPosition(mockNode)
  4. VERIFY: Fallback behavior or graceful failure
  5. VERIFY: No Lua error

Test 3: Performance Comparison
  BEFORE FIX:
    Call UpdateGauntletPosition() 100 times
    Measure time
  AFTER FIX:
    Call UpdateGauntletPosition() 100 times
    Measure time
  VERIFY: Significant improvement (>50% faster)
```

**Edge Cases to Consider:**
```
Edge 1: Node Index Lookup Fails
  Node exists but NavGraph:NodeToIndex() returns nil
  Must handle gracefully

Edge 2: Position Changed After Cache
  Node position cached as (100, 200)
  Frame moves to (150, 250)
  Question: Should we detect this?

Edge 3: Gauntlet Update Before Graph Built
  UpdateGauntletPosition called before EnableNavigation
  No graph exists yet
  Must not crash

Edge 4: Animated Frames
  Frame is animating (moving)
  Cached position is outdated
  Question: Recache or accept slight offset?

Edge 5: Scaled UI
  User has UI scale set to 0.5 or 2.0
  Are cached positions scale-corrected?
```

**Alternative Solutions to Explore:**
```
Option A: Always Use Cached (Recommended)
  NodeToIndex â†’ GetNodePosition â†’ SetPoint
  Pros: Fastest, simplest
  Cons: Doesn't handle dynamic frames

Option B: Cache with Refresh
  Use cached position
  If node moved (compare), recache
  Pros: Handles dynamic frames
  Cons: Adds position comparison cost

Option C: Lazy Cache
  Use NODE.GetCenterScaled first call
  Cache result for future calls
  Clear cache on navigation
  Pros: Flexible
  Cons: More complex caching logic

Option D: Hybrid Approach
  Use cached for graph nodes
  Use NODE for non-graph nodes (edge case)
  Pros: Handles all cases
  Cons: Two code paths
```

---

### Bug 4: Unvalidated Tooltip Ownership (UX Issue)

**Suspected Problem:**
HideTooltip() hides GameTooltip without checking if it belongs to the current navigation, potentially hiding tooltips from other addons or UI elements.

**Where to Look:**
- Hijack.lua - HideTooltip() method
- Hijack.lua - ShowNodeTooltip() method
- Hijack.lua - SetFocus() method (calls HideTooltip?)

**Investigation Steps:**
1. Find HideTooltip() implementation
2. Check if it validates tooltip owner
3. Check GameTooltip:GetOwner() usage
4. Look at ShowNodeTooltip() - does it set owner correctly?
5. Check SetFocus() - when does it hide tooltip?

**Expected Findings:**
```lua
// Suspected problematic code:
function Hijack:HideTooltip()
    if GameTooltip:IsShown() then
        GameTooltip:Hide()  // âŒ Hides ANY tooltip, not just ours
    end
end

function Hijack:ShowNodeTooltip(node)
    // Does it set owner?
    GameTooltip:SetOwner(node, "ANCHOR_RIGHT")  // âœ… or âŒ?
end
```

**Impact Assessment Criteria:**
- **Critical:** Breaks other addons
- **High:** Frequently hides wrong tooltips
- **Medium:** Occasionally hides wrong tooltips
- **Low:** Rare edge case

**Questions to Answer:**
- Does HideTooltip() check owner before hiding?
- What is GameTooltip:GetOwner() when we show tooltip?
- Does ShowNodeTooltip() set owner correctly?
- Can GameTooltip have no owner (nil owner)?
- What about ItemRefTooltip or other tooltip frames?
- When is HideTooltip() called? (every navigation? SetFocus?)

**Solution Design Requirements:**
- Check GameTooltip:GetOwner() before hiding
- Only hide if owner is CurrentNode, UIParent, or nil
- Handle nil owner case
- Consider ItemRefTooltip separately
- Log when refusing to hide tooltip (debug)

**Test Cases to Design:**
```
Test 1: Own Tooltip (Should Hide)
  1. Enable navigation, focus on button
  2. ShowNodeTooltip displays our tooltip
  3. Navigate to different button
  4. VERIFY: Previous tooltip hidden
  5. VERIFY: New tooltip shown

Test 2: External Tooltip (Should NOT Hide)
  1. Enable navigation
  2. Hover over item in bags (creates item tooltip)
  3. Navigate with D-pad
  4. VERIFY: Item tooltip NOT hidden
  5. VERIFY: Navigation still works

Test 3: No Owner Tooltip (Should Hide)
  1. Create tooltip with no owner
  2. Enable navigation
  3. Call HideTooltip()
  4. VERIFY: Tooltip hidden (safe default)

Test 4: Rapid Navigation (No Flicker)
  1. Navigate rapidly between 5 buttons
  2. VERIFY: Tooltips transition smoothly
  3. VERIFY: No visible flicker
  4. VERIFY: No orphaned tooltips
```

**Edge Cases to Consider:**
```
Edge 1: ItemRefTooltip
  User clicks item link in chat
  ItemRefTooltip shows
  Question: Should we hide this?

Edge 2: Multiple Tooltip Frames
  Some addons use custom tooltip frames
  Question: Do we need to check those too?

Edge 3: Tooltip Owner Becomes Invalid
  Tooltip owner is a button that gets hidden
  Owner frame no longer valid
  Question: How does GetOwner() behave?

Edge 4: Tooltip Set By OnEnter Script
  ShowNodeTooltip() calls node:OnEnter()
  That script sets its own tooltip owner
  Question: Can we determine correct owner?

Edge 5: Tooltip During Combat
  Navigation disabled in combat
  But tooltip might still be shown
  Question: Should we hide on combat start?
```

**Alternative Solutions to Explore:**
```
Option A: Owner Whitelist (Recommended)
  Only hide if owner in our whitelist
  [CurrentNode, UIParent, nil]
  Pros: Conservative, safe
  Cons: Might leave orphaned tooltips

Option B: Owner Blacklist
  Hide unless owner is known external frame
  Check against list of protected frames
  Pros: More aggressive cleanup
  Cons: Hard to maintain blacklist

Option C: Track Our Tooltips
  Set a flag when we show tooltip
  Only hide if flag is set
  Clear flag after hiding
  Pros: Precise ownership tracking
  Cons: Requires more state management

Option D: Tooltip Ownership Table
  Store {tooltip â†’ owner} mapping
  Check mapping before hiding
  Pros: Accurate
  Cons: Memory overhead
```

---

### Bug 5: Duplicate Hook Registration (Memory Leak)

**Suspected Problem:**
RegisterVisibilityHooks() may be called multiple times (e.g., on addon reload, on re-enable), creating duplicate hooks that waste memory and cause duplicate event triggers.

**Where to Look:**
- Hijack.lua - RegisterVisibilityHooks() method
- Hijack.lua - OnEnable() method (where is it called?)
- Check for VisibilityHooksRegistered flag

**Investigation Steps:**
1. Find RegisterVisibilityHooks() implementation
2. Check where it's called (OnEnable? OnInitialize?)
3. Look for guard flag to prevent duplicate registration
4. Check if OnDisable() clears the flag
5. Look for :HookScript() calls - are they conditional?

**Expected Findings:**
```lua
// Suspected problematic code:
function Hijack:RegisterVisibilityHooks()
    // No guard flag check!
    for _, frameName in ipairs(ALLOWED_FRAMES) do
        local frame = _G[frameName]
        if frame then
            frame:HookScript('OnShow', OnFrameShow)  // âŒ Hooks every call
            frame:HookScript('OnHide', OnFrameHide)
        end
    end
end

function Hijack:OnEnable()
    self:RegisterVisibilityHooks()  // Called on every enable
end
```

**Impact Assessment Criteria:**
- **Critical:** Significant memory leak (>1MB per hour)
- **High:** Noticeable memory growth (>100KB per hour)
- **Medium:** Minor memory leak (<100KB per hour)
- **Low:** Negligible memory impact

**Questions to Answer:**
- Is there a VisibilityHooksRegistered flag?
- Where is RegisterVisibilityHooks() called?
- How many times can OnEnable() be called? (once? multiple?)
- Does addon reload trigger re-registration?
- Can you verify hooks are duplicated (test mentally)?
- Are there other hook registrations with same issue?

**Solution Design Requirements:**
- Add VisibilityHooksRegistered flag (boolean)
- Check flag at start of RegisterVisibilityHooks()
- Set flag to true after successful registration
- Optional: Track hooks in table for unhooking
- Log when skipping duplicate registration

**Test Cases to Design:**
```
Test 1: Normal Registration (First Call)
  1. Addon loads, OnEnable() called
  2. RegisterVisibilityHooks() called first time
  3. VERIFY: Hooks registered
  4. VERIFY: VisibilityHooksRegistered = true
  5. VERIFY: Log: "Registered visibility hooks"

Test 2: Duplicate Prevention (Second Call)
  1. Hooks already registered
  2. Call RegisterVisibilityHooks() again
  3. VERIFY: Early return due to flag
  4. VERIFY: No duplicate hooks
  5. VERIFY: Log: "Hooks already registered, skipping"

Test 3: Addon Reload
  1. /reload ui command
  2. Addon OnEnable() called again
  3. VERIFY: Hooks re-registered (flag reset on reload)
  4. VERIFY: No duplicate hooks (old ones cleared by reload)

Test 4: Memory Leak Test
  BEFORE FIX:
    Call RegisterVisibilityHooks() 100 times
    Measure memory usage
  AFTER FIX:
    Call RegisterVisibilityHooks() 100 times
    Measure memory usage
  VERIFY: No memory growth after first call
```

**Edge Cases to Consider:**
```
Edge 1: Frame Doesn't Exist At Registration
  Frame in ALLOWED_FRAMES but not created yet
  Question: Re-register when frame appears?

Edge 2: Frame Created Mid-Session
  New bag slot added (ContainerFrame13)
  Not in ALLOWED_FRAMES at startup
  Question: Dynamic hook registration?

Edge 3: Hook Failure
  frame:HookScript() fails (protected frame)
  Question: Set flag or retry later?

Edge 4: OnDisable() Behavior
  Should flag be reset on OnDisable()?
  If yes, can cause re-registration issues
  If no, can prevent re-registration after disable

Edge 5: Multiple Addon Instances
  Edge case: Two CPLight instances
  Question: Global flag or per-instance?
```

**Alternative Solutions to Explore:**
```
Option A: Simple Boolean Flag (Recommended)
  if self.VisibilityHooksRegistered then return end
  // Register hooks
  self.VisibilityHooksRegistered = true
  
  Pros: Simple, effective
  Cons: No way to unhook

Option B: Hook Table Tracking
  self.RegisteredHooks = {}
  Store {frame â†’ handler} mapping
  Check table before hooking
  
  Pros: Can unhook later, precise
  Cons: More complex

Option C: Once-Per-Session Registration
  Use global flag instead of instance flag
  _G.CPLightHooksRegistered = true
  
  Pros: Works across reloads
  Cons: Can't re-register if needed

Option D: Reference Counting
  Track hook count per frame
  Only unhook when count reaches 0
  
  Pros: Handles multiple registrations
  Cons: Overly complex for this use case
```

---

## Report Format

For each bug, provide this structure:

```markdown
## Bug X: [Bug Name]

### Status
â˜‘ï¸ Confirmed / âš ï¸ Partially Exists / âŒ Not Found / âœ… Already Fixed

### Location
File: [filename]
Method: [method name]
Lines: [line numbers]

### Code Snippet
```lua
// Actual problematic code found
```

### Impact Assessment
Severity: Critical / High / Medium / Low
Frequency: Always / Often / Sometimes / Rare
User Impact: [description]

### Root Cause Analysis
[Explain WHY the bug exists and what causes it]

### Reproduction Steps
1. [Step 1]
2. [Step 2]
3. [Expected: X, Actual: Y]

### Solution Design
#### Approach
[High-level strategy]

#### Pseudo-code
```lua
// Detailed pseudo-code showing the fix
// DO NOT write actual implementation
```

#### Implementation Steps
1. [Step 1]
2. [Step 2]
...

### Test Cases
#### Test 1: [Name]
- **Setup:** [Initial state]
- **Action:** [What to do]
- **Verify:** [Expected outcome]

#### Test 2: [Name]
...

### Edge Cases
1. **Edge 1:** [Description]
   - **Scenario:** [When it happens]
   - **Handling:** [How solution handles it]

2. **Edge 2:** ...

### Alternative Solutions
#### Option A: [Name]
- **Approach:** [Description]
- **Pros:** [Advantages]
- **Cons:** [Disadvantages]
- **Recommendation:** â­ Recommended / âŒ Not Recommended

#### Option B: ...

### Improvements Beyond Fix
- [Additional enhancement 1]
- [Additional enhancement 2]

---
```

## Files to Investigate

1. **`View/Hijack.lua`** (Primary focus)
   - All 5 bugs likely here

2. **`View/NavigationGraph.lua`** (Supporting)
   - Bug 3: Check if positions cached

3. **`View/Actions.lua`** (Context)
   - May provide insights

---

## Success Criteria

Your investigation is complete when you can answer for each bug:
- âœ… Does it exist? (with proof)
- âœ… What's the impact?
- âœ… How to reproduce it?
- âœ… What's the solution? (detailed design)
- âœ… How to test it?
- âœ… What are the edge cases?
- âœ… Are there better alternatives?

---

## Critical Instructions

1. **READ FIRST, ANALYZE SECOND** - Don't jump to conclusions
2. **PROOF REQUIRED** - Show actual code snippets as evidence
3. **DESIGN ONLY** - Do NOT implement code
4. **BE THOROUGH** - Consider all edge cases
5. **BE HONEST** - If bug doesn't exist, say so
6. **BE CREATIVE** - Suggest improvements beyond the fix

---

Please begin your bug investigation now. Start by reading View/Hijack.lua and View/NavigationGraph.lua completely, then systematically investigate each suspected bug.## Files to Investigate

1. **`View/Hijack.lua`** (Primary focus)
   - All 5 bugs likely here

2. **`View/NavigationGraph.lua`** (Supporting)
   - Bug 3: Check if positions cached

3. **`View/Actions.lua`** (Context)
   - May provide insights

---

## Success Criteria

Your investigation is complete when you can answer for each bug:
- âœ… Does it exist? (with proof)
- âœ… What's the impact?
- âœ… How to reproduce it?
- âœ… What's the solution? (detailed design)
- âœ… How to test it?
- âœ… What are the edge cases?
- âœ… Are there better alternatives?

---

## Critical Instructions

1. **READ FIRST, ANALYZE SECOND** - Don't jump to conclusions
2. **PROOF REQUIRED** - Show actual code snippets as evidence
3. **DESIGN ONLY** - Do NOT implement code
4. **BE THOROUGH** - Consider all edge cases
5. **BE HONEST** - If bug doesn't exist, say so
6. **BE CREATIVE** - Suggest improvements beyond the fix

---

Please begin your bug investigation now. Start by reading View/Hijack.lua and View/NavigationGraph.lua completely, then systematically investigate each suspected bug.